//*****************************************************************************
//
//! @file deepsleep_shipmode.c
//!
//! @brief Example demonstrating how to enter deepsleep with no memory retention
//!        and wakeup from an interrupt source followed by an immediate software
//!        reset
//!
//! @addtogroup power_examples Power Examples
//!
//! @defgroup deepsleep_shipmode Deepsleep Shipmode Example
//! @ingroup power_examples
//! @{
//!
//! Purpose: This example demonstrates deep sleep ship mode
//! functionality for battery power preservation during shipping or shelf life.
//! The application showcases power management with no memory retention,
//! GPIO wake-up sources, and immediate software reset upon wake-up.
//!
//! @section deepsleep_shipmode_features Key Features
//!
//! 1. @b Ship @b Mode @b Power: Implements deep sleep with no memory
//!    retention for battery preservation during shipping
//!
//! 2. @b GPIO @b Wake @b Source: Provides GPIO interrupt wake-up source
//!    for flexible power management scenarios
//!
//! 3. @b Software @b Reset: Implements immediate software reset upon
//!    wake-up for application restart capability
//!
//! 4. @b Memory @b Management: Configures memory for low power with
//!    no retention in deep sleep for minimal power consumption
//!
//! 5. @b Assembly @b Implementation: Uses pure assembly for sleep entry
//!    and reset to guarantee no unwanted stack access
//!
//! @section deepsleep_shipmode_functionality Functionality
//!
//! The application performs the following operations:
//! - Initializes memory for low power with no retention in deep sleep
//! - Configures GPIO interrupt as wake-up source
//! - Places device into deep sleep for battery preservation
//! - Measures current draw during ship mode operation
//! - Implements immediate software reset upon wake-up
//! - Provides ship mode power management
//!
//! @section deepsleep_shipmode_usage Usage
//!
//! 1. Compile and download the application to target device
//! 2. Monitor UART output at 115,200 BAUD for status messages
//! 3. Measure current draw during deep sleep operation
//! 4. Press push button to wake up the device
//! 5. Observe immediate software reset and device restart
//!
//! @section deepsleep_shipmode_configuration Configuration
//!
//! - @b INTERRUPT_GPIO: GPIO pin for wake-up source configuration
//! - @b Memory @b Retention: No memory retention for minimal power
//! - @b Assembly @b Processing: Pure assembly implementation for reliability
//! - @b UART @b Configuration: 115,200 BAUD, 8 bit, no parity
//!
//! Note: The API am_hal_PRE_SLEEP_PROCESSING which handles the deep sleep entry
//! as well as the software reset command upon wakeup is written in pure assembly
//! to guarantee no unwanted stack access generated by the compiler, as the stack
//! would be invalid after the wakeup since all information will be lost when RAM
//! is powered down in sleep.
//!
//! Text is output to the UART at 115,200 BAUD, 8 bit, no parity.<br>
//! Please note that text end-of-line is a newline (LF) character only.<br>
//! Therefore, the UART terminal must be set to simulate a CR/LF.<br>
//
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 2025, Ambiq Micro, Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
// contributors may be used to endorse or promote products derived from this
// software without specific prior written permission.
//
// Third party software included in this distribution is subject to the
// additional license terms as defined in the /docs/licenses directory.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// This is part of revision release_sdk5p0p1-61912905f0 of the AmbiqSuite Development Package.
//
//*****************************************************************************

#include "am_mcu_apollo.h"
#include "am_bsp.h"
#include "am_util.h"
#ifdef AM_BSP_IS_SIP
#include "am_devices_em9305.h"
#endif

#if (AM_BSP_NUM_BUTTONS > 0)
#define INTERRUPT_GPIO      AM_BSP_GPIO_BUTTON0
#else
#ifdef AM_PART_APOLLO330P_510L
//
// Must define a deepersleep-wake-capable pin for this device (5-6, 8-21).
//
#define INTERRUPT_GPIO      16
#else
#define INTERRUPT_GPIO      0       // custom define
#endif
#endif

//*****************************************************************************
//
// GPIO interrupt IRQn and ISR macros
//
//*****************************************************************************
#if INTERRUPT_GPIO <= 31
#define GPIO_INT_IRQN       GPIO0_001F_IRQn
#define am_gpio_isr         am_gpio0_001f_isr
#elif INTERRUPT_GPIO <= 63
#define GPIO_INT_IRQN       GPIO0_203F_IRQn
#define am_gpio_isr         am_gpio0_203f_isr
#elif INTERRUPT_GPIO <= 95
#define GPIO_INT_IRQN       GPIO0_405F_IRQn
#define am_gpio_isr         am_gpio0_405f_isr
#elif INTERRUPT_GPIO <= 127
#define GPIO_INT_IRQN       GPIO0_607F_IRQn
#define am_gpio_isr         am_gpio0_607f_isr
#elif INTERRUPT_GPIO <= 159
#define GPIO_INT_IRQN       GPIO0_809F_IRQn
#define am_gpio_isr         am_gpio0_809f_isr
#else
#error Invalid INTERRUPT_GPIO specified.
#endif

//
// addresses of the register to be accessed in am_hal_PRE_SLEEP_PROCESSING API
//
const uint32_t ui32CpdlpstateAddr = (uint32_t)&(PWRMODCTL -> CPDLPSTATE);
const uint32_t ui32SyncReadAddr = (uint32_t)SYNC_READ;
const uint32_t ui32SwpoiAddr = (uint32_t)&(RSTGEN -> SWPOI);

//*****************************************************************************
//
// GPIO initialization routine
// Configures push button 0 as input with rising edge interrupt enabled
//
//*****************************************************************************
void
am_init_gpio(void)
{
    //
    // Configure GPIO push button as an interrupt wakeup source
    //
    am_hal_gpio_mask_t GpioIntMask = AM_HAL_GPIO_MASK_DECLARE_ZERO;

    //
    // GPIO configuration as input with rising edge interrupt enabled
    //
    am_hal_gpio_pincfg_t sInPinCfg = AM_HAL_GPIO_PINCFG_DEFAULT;
    sInPinCfg.GP.cfg_b.eIntDir = AM_HAL_GPIO_PIN_INTDIR_LO2HI;
    sInPinCfg.GP.cfg_b.eGPInput = AM_HAL_GPIO_PIN_INPUT_ENABLE;
    sInPinCfg.GP.cfg_b.eDriveStrength = AM_HAL_GPIO_PIN_DRIVESTRENGTH_0P5X;
#if (AM_BSP_NUM_BUTTONS == 0)
    sInPinCfg.GP.cfg_b.ePullup = AM_HAL_GPIO_PIN_PULLDOWN_50K;
#endif

    //
    // Configure push button 0
    //
    uint32_t ui32PinTestIntrpt = INTERRUPT_GPIO;
    am_hal_gpio_pinconfig(ui32PinTestIntrpt, sInPinCfg);

    //
    // Enable Interrupt for push button 0
    //
    am_hal_gpio_interrupt_control(AM_HAL_GPIO_INT_CHANNEL_0,
                                  AM_HAL_GPIO_INT_CTRL_INDV_ENABLE,
                                  &ui32PinTestIntrpt);

    //
    // Read the GPIO Interrupt Status for push button 0
    //
    am_hal_gpio_interrupt_status_get(AM_HAL_GPIO_INT_CHANNEL_0,
                                     true, &GpioIntMask);

    //
    // Clear GPIO interrupts for push button 0
    //
    am_hal_gpio_interrupt_clear(AM_HAL_GPIO_INT_CHANNEL_0, &GpioIntMask);

    //
    // Enable NVIC to receive interrupt trigger
    //
    NVIC_ClearPendingIRQ(GPIO_INT_IRQN);
    NVIC_EnableIRQ(GPIO_INT_IRQN);

    //
    // Set PRIMASK bit to prevent interrupt being served.
    // The intention is only to let interrupt wakeup the processor
    //
    am_hal_interrupt_master_disable();
}

//*****************************************************************************
//
// This function is weakly defined in am_hal_sysctrl.c
// Override weakly defined PRE_SLEEP_PROCESSING function
// Disable cache, invoke WFI, and initiate system level reset upon wake up
// This function is written in assembly language to prevent unwanted RAM and
// stack access generated by the compiler. Since all RAM memory is powered off
// in deep sleep, there won't be a valid stack and all information stored on
// RAM will be lost. Therefore we want to be in full control for any potential
// memory access.
//
//*****************************************************************************
#if defined(__GNUC__)               // If compiler is GCC or ARM6
__attribute((naked))
#elif defined(__IAR_SYSTEMS_ICC__)  // if compiler is IAR
__stackless
#endif
void
am_hal_PRE_SLEEP_PROCESSING(void)
{
#if defined(__IAR_SYSTEMS_ICC__)
    //
    // Configure CPLDSTATE register for lowest power in deepsleep
    //
    __asm volatile
    (
        " ldr   r0, = ui32CpdlpstateAddr\n"  // load address of ui32CpdlpstateAddr into R0
        " ldr   r0, [r0]\n"                  // load CPDLPSTATE register address into R0
        " ldr   r1, = 0x00000333\n"          // load register configuration value into R1
                                             // The value will configure the CPDLPSTATE such that
                                             // RLP, ELP, and CLP are all off
        " str   r1, [r0]\n"                  // write register value to CPDLPSTATE register

    );

    //
    // Flush system buses
    //
    __asm volatile
    (
        " ldr   r0, = ui32SyncReadAddr\n"     // read memory address that contains sync read address
        " ldr   r0, [r0]\n"                   // load sync read register address into R0
        " ldr   r1, [r0]\n"                   // load sync read register value into R1
    );
#else
    //
    // Configure CPLDSTATE register for lowest power in deepsleep
    //
    __asm volatile
    (
        " ldr   r0, %[ui32CpdlpstateAddrAsm]\n"     // load PWRMODCTL -> CPDLPSTATE address onto R0
        " ldr   r1, = 0x00000333\n"                 // load register configuration value into R1
                                                    // The value will configure the CPDLPSTATE such that
                                                    // RLP, ELP, and CLP are all off
        " str   r1, [r0]\n"                         // write register value to CPDLPSTATE
        :
        :
        [ui32CpdlpstateAddrAsm] "m" (ui32CpdlpstateAddr)  // assembly code variable referencing

    );

    //
    // Flush system buses
    //
    __asm volatile
    (
        " ldr   r0, %[ui32SyncReadAddrAsm]\n"     // load sync read register address into R0
        " ldr   r1, [r0]\n"                       // load sync read register value into R1
        :
        :
        [ui32SyncReadAddrAsm] "m" (ui32SyncReadAddr)  // assembly code variable referencing
    );
#endif

    //
    // Enter Deepsleep and call ISB upon wakeup
    //
    __asm volatile ("wfi":::"memory");
#if defined(__GNUC__)
    __asm volatile ("isb 0xF":::"memory");
#else
    __asm volatile ("isb":::"memory");
#endif

#if defined(__IAR_SYSTEMS_ICC__)
    //
    // Initiate a POI after wakeup
    //
    __asm volatile
    (
        " ldr   r0, = ui32SwpoiAddr\n"     // load memory address that contais ui32SwpoiAddr into R0
        " ldr   r0, [r0]\n"                // load RSTGEN -> SWPOI value into R0
        " ldr   r1, = 0x1B\n"              // load 0x1B into R1
        " str   r1, [r0]\n"                // write 0x1B to RSTGEN -> SWPOI to initiate POI reset
    );
#else
    //
    // Initiate a POI after wakeup
    //
    __asm volatile
    (
        " ldr   r0, %[ui32SwpoiAddrAsm]\n"     // load RSTGEN -> SWPOI address into R0
        " ldr   r1, = 0x1B\n"                  // load 0x1B into R1
        " str   r1, [r0]\n"                    // write 0x1B to RSTGEN -> SWPOI to initiate POI reset
        :
        :
        [ui32SwpoiAddrAsm] "m" (ui32SwpoiAddr)  // assembly code variable referencing
    );
#endif
}

//*****************************************************************************
//
// Main function.
//
//*****************************************************************************
int
main(void)
{
    //
    // NVM, SRAM, and TCM configuration. No retention when in sleep mode
    //
    am_hal_pwrctrl_mcu_memory_config_t McuMemCfg =
    {
        //
        // In order to demonstrate the lowest possible power,
        // this example enables the ROM automatic power down feature.
        // This should not be used in general for most applications.
        //
        .eROMMode       = AM_HAL_PWRCTRL_ROM_AUTO,

#ifdef AM_PART_APOLLO330P_510L
        .eDTCMCfg       = AM_HAL_PWRCTRL_DTCM128K,
        .eNVMCfg        = AM_HAL_PWRCTRL_NVM,
#else
        .eDTCMCfg       = AM_HAL_PWRCTRL_ITCM32K_DTCM128K,
        .eNVMCfg        = AM_HAL_PWRCTRL_NVM0_ONLY,
#endif
        .eRetainDTCM    = AM_HAL_PWRCTRL_MEMRETCFG_TCMPWDSLP_NORETAIN,
        .bKeepNVMOnInDeepSleep     = false
    };

    am_hal_pwrctrl_sram_memcfg_t SRAMMemCfg =
    {
        .eSRAMCfg         = AM_HAL_PWRCTRL_SRAM_NONE,
        .eActiveWithMCU   = AM_HAL_PWRCTRL_SRAM_NONE,
        .eActiveWithGFX   = AM_HAL_PWRCTRL_SRAM_NONE,
        .eActiveWithDISP  = AM_HAL_PWRCTRL_SRAM_NONE,
        .eSRAMRetain      = AM_HAL_PWRCTRL_SRAM_NONE
    };

    //
    // structure to configure the CPDLPSTATE, to be read from pwrctrl
    //
    am_hal_pwrctrl_pwrmodctl_cpdlp_t psCpdlpConfig =
    {
        .eClpConfig = AM_HAL_PWRCTRL_CLP_ON,
        .eElpConfig = AM_HAL_PWRCTRL_ELP_ON,
        .eRlpConfig = AM_HAL_PWRCTRL_RLP_ON
    };

    //
    // Configure the board for low power.
    //
    am_bsp_low_power_init();

    //
    // If Apollo510B device, turn off EM9305 to save power
    //
#ifdef AM_BSP_IS_SIP
    am_devices_em9305_shutdown();
#endif

#ifdef AM_PART_APOLLO330P_510L
    //
    // Power off the RSS
    //
    am_hal_pwrctrl_rss_pwroff();
#endif

    //
    // Initialize the printf interface for UART output.
    //
    am_bsp_uart_printf_enable();

    //
    // Print the banner.
    //
    am_util_stdio_terminal_clear();
    am_util_stdio_printf("Deepsleep Shipmode Example\n");
#if (AM_BSP_NUM_BUTTONS > 0)
    am_util_stdio_printf("Press push button 0 to wakeup and reset the device\n");
#else
    am_util_stdio_printf("Please toggle gpio %d low to high\n", INTERRUPT_GPIO);
#endif

    //
    // To minimize power during the run, disable the UART.
    //
    am_bsp_uart_printf_disable();

    //
    // Disable cache, prepare to power off the cache
    //
    am_hal_cachectrl_dcache_disable();
    am_hal_cachectrl_icache_disable();

    //
    // Reconfigure CPDLPSTATE RLP to off, and power off the cache completely
    //
    am_hal_pwrctrl_pwrmodctl_cpdlp_get(&psCpdlpConfig);
    psCpdlpConfig.eRlpConfig = AM_HAL_PWRCTRL_RLP_OFF;
    am_hal_pwrctrl_pwrmodctl_cpdlp_config(psCpdlpConfig);
    am_hal_cachectrl_caches_power_control(false);


    am_hal_rtc_osc_select(AM_HAL_RTC_OSC_LFRC); // Use LFRC instead of XT

    //
    // Configure XTAL for deepsleep
    //
    am_hal_pwrctrl_control(AM_HAL_PWRCTRL_CONTROL_XTAL_PWDN_DEEPSLEEP, 0);

    //
    // Disable RTC Oscillator
    //
    am_hal_rtc_osc_disable();

    //
    // Disable all peripherals including Crypto
    //
    am_hal_pwrctrl_control(AM_HAL_PWRCTRL_CONTROL_DIS_PERIPHS_ALL, 0);

    //
    // Power off voltage comparator
    //
    VCOMP -> PWDKEY = VCOMP_PWDKEY_PWDKEY_Key;

    //
    // Disable Debug Subsystem
    //
    MCUCTRL->DBGCTRL = 0;

    //
    // Configure MRAM and TCM for deep sleep with no retention
    //
    am_hal_pwrctrl_mcu_memory_config(&McuMemCfg);

    //
    // MRAM0 LP Setting affects the Latency to wakeup from Sleep. Hence, it should be configured in the application.
    // Configure the MRAM for low power mode
    //
    MCUCTRL->MRAMCRYPTOPWRCTRL_b.MRAM0LPREN = 1;
    MCUCTRL->MRAMCRYPTOPWRCTRL_b.MRAM0SLPEN = 0;
    MCUCTRL->MRAMCRYPTOPWRCTRL_b.MRAM0PWRCTRL = 1;

    //
    // Disable SRAM
    //
    am_hal_pwrctrl_sram_config(&SRAMMemCfg);

    //
    // GPIO initialization, configure push button 0 as an interrupt source when pressed down
    //
    am_init_gpio();

    while (1)
    {
        //
        // Go to Deep Sleep and stay there. A press on push button 0 will wakeup the device
        // and directly initialize a system reset within the PRESLEEP_PROCESSING API
        //
#ifdef AM_PART_APOLLO330P_510L
            am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEPER);
#else
            am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
#endif
    }
}

//*****************************************************************************
//
// End Doxygen group.
//! @}
//
//*****************************************************************************
